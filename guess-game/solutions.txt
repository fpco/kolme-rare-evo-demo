just serve

just test-bets

No API server, uncomment the API server in main.

just serve, just test-bets

Implement grab_funds

// src/app.rs grab_funds
    let sender = ctx.get_sender_id();
    let height = ctx.block_height();
    let old = ctx.state_mut().received_funds.insert(sender, height);
    anyhow::ensure!(
        old.is_none(),
        "Account {} already received funds",
        ctx.get_sender_id()
    );
    ctx.mint_asset(ASSET_ID, sender, rust_decimal::dec! {100})?;
    Ok(())

just serve, just test-bets

Implement place_bet

// src/app.rs place_bet

    let sender = ctx.get_sender_id();
    let timestamp = GuessTimestamp::after(ctx.block_time());
    ctx.burn_asset(ASSET_ID, sender, amount)?;
    ctx.state_mut()
        .pending_wagers
        .get_or_default(timestamp)
        .push(Wager {
            account: sender,
            guess,
            amount,
        });
    ctx.log_json(&GuessGameLog::Wager {
        account: sender,
        timestamp,
        guess,
        amount,
    })?;
    Ok(())

Nothing happens... need to create a job to settle markets

src/main.rs, spawn bots, relaunch

It fails...

// bot.rs
    let kolme_r = kolme.read();
    let Some((guess_timestamp, _wagers)) = kolme_r.get_app_state().pending_wagers.iter().next()
    else {
        return Ok(());
    };
    let timestamp = Timestamp::from(guess_timestamp);
    if timestamp > Timestamp::now() {
        return Ok(());
    }
    let result = rng_server.get_result(*guess_timestamp).await?;
    kolme
        .sign_propose_await_transaction(
            secret,
            vec![Message::App(GuessMessage::SettleBet { result })],
        )
        .await?;
    Ok(())

Need to implement the settle bets logic too

// src/app.rs settle_bet
    let pubkey = result.verify_signature()?;
    anyhow::ensure!(pubkey == ctx.app_state().rng_public_key);
    let RngResult { number, timestamp } = result.message.as_inner();
    let timestamp = GuessTimestamp::try_from(*timestamp)?;
    let wagers = ctx
        .app_state_mut()
        .pending_wagers
        .remove(&timestamp)
        .context("No pending wagers for given timestamp found")?
        .1;
    let number = (*number % 256) as u8;

    let mut total_bet = Decimal::ZERO;
    let mut winning_weights = HashMap::<_, Decimal>::new();
    let mut winning_distance = u8::MAX;
    let mut total_weight = Decimal::ZERO;

    for Wager {
        account,
        guess,
        amount,
    } in wagers
    {
        total_bet += amount;
        let distance = guess.abs_diff(number);
        match distance.cmp(&winning_distance) {
            // New winner! Flush out the old values.
            std::cmp::Ordering::Less => {
                winning_distance = distance;
                winning_weights.clear();
                total_weight = Decimal::ZERO;
            }
            // This is also a winner
            std::cmp::Ordering::Equal => (),
            // Not a winner :(
            std::cmp::Ordering::Greater => continue,
        }
        *winning_weights.entry(account).or_default() += amount;
        total_weight += amount;
    }

    ctx.log_json(&GuessGameLog::NewWinner {
        finished: timestamp,
        number,
    })?;

    for (winner, weight) in winning_weights {
        let amount = total_bet * weight / total_weight;
        ctx.log_json(&GuessGameLog::Winnings {
            finished: timestamp,
            winner,
            amount,
        })?;
        ctx.mint_asset(ASSET_ID, winner, amount)?;
    }

    Ok(())

Game is settling... let's look up the state!

curl http://localhost:3000/guess-game

Oops, didn't implement it yet!

// api.rs

    let RouteState { kolme, indexer } = route_state;
    let indexer_state = indexer.read().await;
    let current_round = GuessTimestamp::after(Timestamp::now());
    let last_winner = indexer_state.results.last_key_value().map(
        |(finished, RoundResults { number, winnings })| LastWinner {
            finished: finished.into(),
            number: *number,
            winnings: winnings.clone(),
        },
    );
    Json(GuessGameData {
        current_round_finishes: current_round.into(),
        current_bets: kolme
            .read()
            .get_app_state()
            .pending_wagers
            .get(&current_round)
            .map_or_else(Decimal::zero, |wagers| {
                wagers.iter().map(|w| w.amount).sum()
            }),
        last_winner,
        leaderboard: indexer_state.leaderboard.clone(),
    })

curl http://localhost:3000/guess-game

Leaderboard is empty, because we haven't actually implemented the indexer yet!

src/main.rs, enable, run and it will crash

// indexer.rs
        let mut next_to_index = BlockHeight::start();
        loop {
            match self.run_once(next_to_index).await {
                Err(e) => {
                    eprintln!("Error while updating indexer for height {next_to_index}: {e}");
                }
                Ok(state) => {
                    *self.state.write().await = state;
                    next_to_index = next_to_index.next();
                }
            }
        }
